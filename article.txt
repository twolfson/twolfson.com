Title: Startup engineering guidelines
Summary: Lessons from the trenches for startups from a 3 x first engineer

Guidelines not rules

Build exactly what you need, nothing more
YAGNI
JIT
Can hedge some ideas but do so in a manner that's easy to blow away if needed
Don't build work you'll need to workaround later

Testing
If experimental feature or visually dependant feature, probably don't
Exceptions: critical to business, has regressed before
Example. Visual testing. Browser level testing and button selectors

If well defined and will make development faster (eg TDD) (link to article), then prob a good idea with free bonus
Example. API. Library

If has lots of edge cases. Use your judgement
Prob at a minimum record manual testing procedure

Otherwise (prob a simple case), use your judgment
If scared it'll break in interesting ways. Hedge on tests
If care about security leaks at this endpoint. Hedge on tests
If only a few simple lines + do manual testing (which should always be done). Prob can skip
Once again. Use your judgement

Stick to boring and simple
SQL
Established framework
Monoliths are ideal since no overhead to maintain syncing between difference parts
You'll have time to go to SOA in the future. Stick to simple for now
There will always be migration and maintenance costs in time
We want to optimize for saving time upfront for right now
Which also impacts engineering velocity

Invest in one button deploys or CD early
It will make deploys instant
And cost savings pays dividends for rest of year. Whereas waiting 1 year for same work is counter productive
You'll always have that same repo, don't lie to yourself

Do it right the first time/fix it now or it will never get fixed
Startup reprioritizations happen instantly

If a reprioritization occurs and an effort is 50% complete,
write out how to resume the effort and what's in progress.
It may be weeks or months until you (or someone else) can get back to this

"Run and gun" style of bug fixing
Most applicable to when joining a company
but there will likely be bugs you see, and want to fix them all
This is an insurmountable mountain to undertake at once.
Write down the bugs as you see them, either in a public or personal list.
And fix them as you find various bouts of downtime (e.g. asked a question, have 1 hour until get a response)
If you can, also prioritize on what has highest cost-value/time-value payoffs (e.g. fixing a typo vs normalizing a response format)

Don't lose sight of the mission
Your goal is the company's goal
We're not in a startup to write or invent a new piece of technology
We're there to make sure the company succeeds in its mission and product
After all, we joined it because of the mission and product

Documentation will help you scale
Document your workflow as its established
You'll forget one-off steps
and when you make your next hire, you'll be second-guessing those steps again
(not to mention time away from programming due to assisting them)

Getting good at documentation sadly is a very slow feedback loop
The best mechanic I've found is tied to open source:
Write docs, revisit them 6 months later once I've forgotten/haven't touched the repo, update/tweak as needed
If your docs are good enough: people rarely need to ask questions and you can even use the docs as your own refresher

---

Article
Extension
Varying levels of formal
Tags in JSON columns
Vs table
Vs elastic search

Or code function abstraction
Vs service

This is when can optimize for 20% of 80/20
But it's a rarity so build what you need primarily. Â 

Analyzing how much work to fix later
And maintenance headaches
Vs it's a temporary experiment so quick hacks good

---

Article
Derisk bus factor
If you got hit by a bus tomorrow, would you feel like the rest of the team would be unable to keep working

Announce/log whenever doing a recurring manual process (ideal automate but startup tradeoffs)

Ensure documentation

Choose boring, well known technology

Don't be clever in code

Anything that's ambiguous in code, leave comments

---

Sentry... is that a lesson somehow?

---

Maintenance costs will eat you alive

Cost of building software breakdown. Build 10%. Maintenance. 90%. Removal 0% :tada:
Also can be viewed as lifecycle

---

Goals can change in an afternoon
Don't over invest

---

Lots of "related to" Or " go back and read" sections

---

Try out 2 formats once all rough content is written out:
- Definitions upfront, then talk through scenarios with definitions A and B
- Current format: Definition + example

- Somehow should communicate that definitions are the knowledge part + examples are the experience/wisdom (though maybe ego stroking)

---

1:10:100 time investment rules

Design mocking (might warrant its own article)
- HTML mocks with mock data
- Figma/etc (diligence + sync ideal)
- HTML with actual data (sometimes fastest depending on models and such)

---

Keep focus. Startup engineer lessons, not general engineering ones
